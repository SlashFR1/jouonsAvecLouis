<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Dixit simplifi√© - version corrig√©e</title>
    <link rel="stylesheet" href="style_dixit2.css" />

</head>

<body>

    <h1>Dixit</h1>
    <h1>Choisissez votre carte</h1>

    <div id="infoJoueur"></div>
    <div id="phraseMa√Ætre"></div>

    <div id="controls">
        <button id="btnReveal" class="hidden">R√©v√©ler les cartes</button>
        <div widjet="container">
            <button id="valider">Valider</button>
        </div>
        <input type="text" id="inputPhrase" placeholder="√âcrire votre phrase ici" style="min-width:320px">
    </div>




    <div id="cartesContainer"></div>
    <div id="zoneVote"></div>

    <div id="scoresBoard"></div>
    <div id="mancheInfo" class="small"></div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // CONFIGURATION / DONN√âES INITIALLES
            const listJoueurs = JSON.parse(localStorage.getItem('joueurs')) || ["Joueur1", "Joueur2", "Joueur3", "Joueur4"];
            const nbJoueurs = listJoueurs.length;
            const totalManches = 3;

            // Exemple de deck: ici on suppose images img1..img40 dans dossier imageDixit/converties/
            const cartesDeck = [];
            for (let i = 1; i <= 40; i++) cartesDeck.push(`imageDixit/converties/img${i}.jpg`);

            // UI elements
            const cartesDiv = document.getElementById("cartesContainer");
            const infoDiv = document.getElementById("infoJoueur");
            const phraseDiv = document.getElementById("phraseMa√Ætre");
            const inputPhrase = document.getElementById("inputPhrase");
            const btnValider = document.getElementById("valider");
            const btnReveal = document.getElementById("btnReveal");
            const zoneVote = document.getElementById("zoneVote");
            const scoresBoard = document.getElementById("scoresBoard");
            const mancheInfo = document.getElementById("mancheInfo");

            // STATE
            let scores = {};
            listJoueurs.forEach(j => scores[j] = 0);

            let mancheActuelle = 1;
            // Hands: { joueur: [carteSrc,...] }
            let mains = {};
            // selections: { joueur: { carte: src, isMaster:boolean, phrase? } }
            let selections = {};
            // votes: { votant: ownerPlayer } (ownerPlayer is the player who owns that card)
            let votes = {};
            // shuffled reveal array: { owner, src, revealIndex }
            let revealList = [];

            // turn state machine
            // phase: "master_pick" -> master chooses phrase+carte
            // "players_pick" -> each non-master chooses card, in order
            // "voting" -> players vote one by one
            // "results" -> display scores, allow next manche
            let phase = "master_pick";
            let masterIndex = Math.floor(Math.random() * listJoueurs.length);;//Maths.random(3); // index in listJoueurs of current master
            let currentPickerIndex = 0; // used during players_pick to point to which player chooses
            let currentVoterIndex = 0; // used during voting to indicate who must vote now (skipping master)
            let masterPlayer = listJoueurs[masterIndex];
            //let masterPlayer = listJoueurs[Maths.random(listJoueurs)]

            // initial distribution
            function distribuerCartes() {
                // copie du deck
                const paquet = [...cartesDeck];
                // shuffle paquet
                for (let i = paquet.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [paquet[i], paquet[j]] = [paquet[j], paquet[i]];
                }
                mains = {};
                let ptr = 0;
                listJoueurs.forEach(j => {
                    mains[j] = [];
                    for (let k = 0; k < 4; k++) {
                        mains[j].push(paquet[ptr++]);
                    }
                });
            }
            // helper to update score display
            function renderScores() {
                scoresBoard.innerHTML = "";
                for (const j of listJoueurs) {
                    const box = document.createElement("div");
                    box.className = "scoreBox";
                    box.innerHTML = `<div><strong>${j}</strong></div><div class="small">${scores[j]} pts</div>`;
                    scoresBoard.appendChild(box);
                }
                mancheInfo.textContent = `Manche ${mancheActuelle} / ${totalManches}`;
            }
            // ------------------- Phase de s√©lection des cartes -------------------
            function renderHandForPlayer(player, mode = "pick") {
                cartesDiv.innerHTML = "";
                zoneVote.innerHTML = "";
                inputPhrase.value = "";

                // Affichage du texte du joueur
                if (mode === "pick" && phase === "master_pick") {
                    infoDiv.textContent = `üé© Ma√Ætre : ${player} ‚Äî √©cris une phrase puis choisis une carte.`;
                } else {
                    infoDiv.textContent = `üëâ ${player}, choisis une carte (ta main).`;
                }

                // On conserve la phrase du ma√Ætre tout au long de la manche
                if (selections[masterPlayer]?.phrase) {
                    phraseDiv.textContent = "üó£Ô∏è Phrase du ma√Ætre : " + selections[masterPlayer].phrase;
                }

                const hand = mains[player];
                if (!hand || hand.length === 0) {
                    const p = document.createElement("div");
                    p.textContent = "Aucune carte dans la main.";
                    cartesDiv.appendChild(p);
                    return;
                }

                // Cr√©e un conteneur pour les cartes
                const cartesZone = document.createElement("div");
                cartesZone.id = "zoneCartesJoueur";
                cartesZone.classList.add("hidden");
                cartesDiv.appendChild(cartesZone);

                // Bouton pour voir les cartes
                const btnVoir = document.createElement("button");
                btnVoir.textContent = "üëÅÔ∏è Voir mes cartes";
                btnVoir.addEventListener("click", () => {
                    cartesZone.classList.toggle("hidden");
                    btnVoir.textContent = cartesZone.classList.contains("hidden") ? "üëÅÔ∏è Voir mes cartes" : "üôà Cacher mes cartes";
                });
                cartesDiv.appendChild(btnVoir);
                if (selections[masterPlayer]?.phrase) {
                    phraseDiv.textContent = "üó£Ô∏è Phrase du ma√Ætre : " + selections[masterPlayer].phrase;
                }

                // Affiche les cartes du joueur
                hand.forEach((src, idx) => {
                    const wrapper = document.createElement("div");
                    wrapper.className = "carte-wrapper";
                    const img = document.createElement("img");
                    img.src = src;
                    img.dataset.index = idx;
                    img.addEventListener("click", () => {
                        if (mode !== "pick") return;
                        cartesZone.querySelectorAll("img").forEach(i => i.classList.remove("selected"));
                        img.classList.add("selected");
                        btnValider.dataset.selectedIndex = idx;
                    });
                    wrapper.appendChild(img);
                    cartesZone.appendChild(wrapper);
                });

                // Avant d'ajouter les boutons
                if (phase === "master_pick" && player === masterPlayer) {
                    inputPhrase.classList.remove("hidden"); // le ma√Ætre peut √©crire
                    if (!inputPhrase.parentNode) {
                        cartesDiv.appendChild(inputPhrase); // ajouter seulement si pas d√©j√† attach√©
                    }
                    btnValider.textContent = "Valider phrase & carte";
                } else {
                    inputPhrase.classList.add("hidden"); // les autres joueurs ne voient rien
                    if (inputPhrase.parentNode) {
                        inputPhrase.parentNode.removeChild(inputPhrase); // retirer du DOM
                    }
                    btnValider.textContent = "Valider carte";
                }


            }
            // called after all players selected their cards
            function prepareRevealAndVoting() {
                // build revealList: array { owner, src }
                revealList = [];
                for (const pl in selections) {
                    revealList.push({ owner: pl, src: selections[pl].carte });
                }
                // shuffle display order
                for (let i = revealList.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [revealList[i], revealList[j]] = [revealList[j], revealList[i]];
                }

                // render phrase
                phraseDiv.textContent = "üó£Ô∏è Phrase du ma√Ætre : " + selections[masterPlayer].phrase;

                // show "R√©v√©ler les cartes" button
                btnReveal.classList.remove("hidden");
                btnReveal.onclick = () => {
                    btnReveal.classList.add("hidden");
                    startVotingPhase();
                };
                infoDiv.textContent = "Cliquez sur 'R√©v√©ler les cartes' pour d√©buter le vote.";
            }
            // ------------------- Phase de vote -------------------
            function startVotingPhase() {
                phase = "voting";
                cartesDiv.innerHTML = "";
                zoneVote.innerHTML = "";
                votes = {};         // { votant: owner }
                voteCount = {};     // compteur de votes par carte

                // M√©lange et affiche les cartes
                revealList.forEach((entry, idx) => {
                    voteCount[idx] = 0;

                    const wrapper = document.createElement("div");
                    wrapper.className = "carte-wrapper";

                    const img = document.createElement("img");
                    img.src = entry.src;
                    wrapper.appendChild(img);

                    const numDiv = document.createElement("div");
                    numDiv.className = "small";
                    numDiv.textContent = `Carte #${idx + 1}`;
                    wrapper.appendChild(numDiv);

                    const countDiv = document.createElement("div");
                    countDiv.className = "vote-count";
                    countDiv.id = `voteCount_${idx}`;
                    countDiv.textContent = `Votes : 0`;
                    wrapper.appendChild(countDiv);

                    const removeBtn = document.createElement("button");
                    removeBtn.textContent = "Retirer vote";
                    removeBtn.className = "remove-vote-btn";
                    wrapper.appendChild(removeBtn);

                    cartesDiv.appendChild(wrapper);

                    // --------- √âcouteur clic carte ----------
                    img.addEventListener("click", () => {
                        const voter = votingOrder[currentVoterIndex];
                        if (!voter) return;

                        if (votes[voter]) {
                            alert(`${voter} a d√©j√† vot√© !`);
                            return;
                        }

                        votes[voter] = entry.owner;
                        voteCount[idx]++;
                        countDiv.textContent = `Votes : ${voteCount[idx]}`;
                        wrapper.querySelector("img").classList.add("selected");

                        // passer au joueur suivant
                        currentVoterIndex++;
                        proceedToNextVoter();
                    });

                    // --------- √âcouteur retirer vote ----------
                    removeBtn.addEventListener("click", (event) => {
                        event.stopPropagation();
                        const voter = votingOrder[currentVoterIndex - 1]; // dernier votant
                        if (votes[voter] === entry.owner) {
                            delete votes[voter];
                            voteCount[idx]--;
                            countDiv.textContent = `Votes : ${voteCount[idx]}`;
                            wrapper.querySelector("img").classList.remove("selected");
                            currentVoterIndex--; // revenir au joueur
                            proceedToNextVoter();
                        }
                    });
                });

                // ordre de vote : tous sauf le ma√Ætre
                votingOrder = listJoueurs.filter(p => p !== masterPlayer);
                currentVoterIndex = 0;
                proceedToNextVoter();
            }
            // ------------------- Avancer au prochain votant -------------------
            function proceedToNextVoter() {
                if (currentVoterIndex >= votingOrder.length) {
                    infoDiv.textContent = "Tous les joueurs ont vot√© !";
                    computeResults();
                    return;
                }
                const voter = votingOrder[currentVoterIndex];
                infoDiv.textContent = `üó≥Ô∏è Au tour de ${voter} de voter (cliquez sur une carte).`;
                // D√©selectionne toutes les cartes
                cartesDiv.querySelectorAll("img").forEach(i => i.classList.remove("selected"));
            }
            // ------------------- Calcul des scores -------------------
            function computeResults() {
                phase = "results";

                const votesRecus = {};
                for (const j of listJoueurs) votesRecus[j] = 0;

                for (const voter in votes) {
                    const owner = votes[voter];
                    if (owner) votesRecus[owner]++;
                }

                const nbVotants = nbJoueurs - 1; // exclut le ma√Ætre
                const votesMaitre = votesRecus[masterPlayer];

                // scoring Dixit
                if (votesMaitre === 0 || votesMaitre === nbVotants) {
                    scores[masterPlayer] += 0;
                    listJoueurs.forEach(p => { if (p !== masterPlayer) scores[p] += 2; });
                } else {
                    scores[masterPlayer] += 3;
                    for (const voter in votes) if (votes[voter] === masterPlayer) scores[voter] += 3;
                    for (const p of listJoueurs) if (p !== masterPlayer) scores[p] += votesRecus[p];
                }

                // afficher les cartes et votes
                cartesDiv.innerHTML = "";
                phraseDiv.textContent = "üó£Ô∏è Phrase du ma√Ætre : " + selections[masterPlayer].phrase;

                revealList.forEach((entry, idx) => {
                    const wrapper = document.createElement("div");
                    wrapper.className = "carte-wrapper";

                    const img = document.createElement("img");
                    img.src = entry.src;
                    img.style.border = entry.owner === masterPlayer ? "3px solid gold" : "2px solid #555";
                    wrapper.appendChild(img);

                    const info = document.createElement("div");
                    info.textContent = `${entry.owner} ‚Äî votes re√ßus : ${votesRecus[entry.owner]}`;
                    wrapper.appendChild(info);

                    cartesDiv.appendChild(wrapper);
                });

                // afficher r√©sum√© des votes
                const voteSummary = document.createElement("div");
                voteSummary.style.marginTop = "12px";
                voteSummary.innerHTML = `<strong>R√©sum√© des votes :</strong><br>` + Object.entries(votes).map(([voter, owner]) => `${voter} ‚Üí ${owner}`).join("<br>");
                zoneVote.innerHTML = "";
                zoneVote.appendChild(voteSummary);

                renderScores();

                // bouton nouvelle manche
                const btnNext = document.createElement("button");
                btnNext.textContent = (mancheActuelle >= totalManches) ? "Terminer et afficher gagnant" : "Nouvelle manche";
                btnNext.addEventListener("click", () => {
                    if (mancheActuelle >= totalManches) announceWinner();
                    else nouvelleManche();
                });
                zoneVote.appendChild(btnNext);
            }

            function revealResults() {
                btnReveal.classList.add("hidden");
                infoDiv.textContent = "R√©sultats finaux :";

                // effet visuel + texte final sous les cartes
                revealList.forEach((entry, idx) => {
                    const count = voteCount[idx];
                    const countDiv = document.getElementById(`voteCount_${idx}`);
                    countDiv.textContent = `Votes : ${count}`;
                    countDiv.style.fontWeight = "bold";
                    countDiv.style.color = count > 0 ? "#ffbf00" : "#ccc";
                });

                // bouton Nouvelle Manche
                const btnNext = document.createElement("button");
                btnNext.textContent = (mancheActuelle >= totalManches) ? "Terminer et afficher gagnant" : "Nouvelle manche";
                btnNext.addEventListener("click", () => {
                    if (mancheActuelle >= totalManches) {
                        announceWinner();
                    } else {
                        nouvelleManche();
                    }
                });

                zoneVote.innerHTML = ""; // efface zone pr√©c√©dente
                zoneVote.appendChild(btnNext);
            }

            btnValider.addEventListener("click", () => {
                const selectedIndex = btnValider.dataset.selectedIndex;
                if (selectedIndex === undefined) {
                    alert("Choisis une carte avant de valider !");
                    return;
                }

                const currentPlayer = players[currentPlayerIndex];

                // Si c‚Äôest le conteur
                if (phase === "master_pick" && currentPlayer === masterPlayer) {
                    const phrase = inputPhrase.value.trim();
                    if (!phrase) {
                        alert("Tu dois √©crire une phrase !");
                        return;
                    }
                    selections[masterPlayer] = {
                        carte: mains[masterPlayer][selectedIndex], // ‚ö†Ô∏è adapte √† "carte" si ton code utilise ce nom
                        phrase
                    };
                    inputPhrase.value = "";
                    phase = "players_pick";
                    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                    renderHandForPlayer(players[currentPlayerIndex]);
                    return;
                }

                // Si c‚Äôest un joueur normal
                selections[currentPlayer] = {
                    carte: mains[currentPlayer][selectedIndex] // idem ici
                };

                currentPlayerIndex++;
                if (currentPlayerIndex < players.length) {
                    renderHandForPlayer(players[currentPlayerIndex]);
                } else {
                    prepareRevealAndVoting(); // ‚Üê on passe √† la phase de r√©v√©lation avant le vote
                }
            });
            // compute points using votes
            function announceWinner() {
                // determine max
                let max = -Infinity, gagnant = "";
                for (const p of listJoueurs) {
                    if (scores[p] > max) { max = scores[p]; gagnant = p; }
                }
                infoDiv.textContent = `üèÜ Fin du jeu ! Le gagnant est ${gagnant} avec ${max} points !`;
                phraseDiv.textContent = "";
                cartesDiv.innerHTML = "";
                zoneVote.innerHTML = "";
            }
            // reset for next manche (rotate master)
            function nouvelleManche() {
                // rotation du ma√Ætre
                masterIndex = (masterIndex + 1) % nbJoueurs;
                masterPlayer = listJoueurs[masterIndex];

                // incr√©mente la manche
                mancheActuelle++;
                if (mancheActuelle > totalManches) {
                    announceWinner();
                    return;
                }

                // r√©initialisation des √©tats
                selections = {};
                votes = {};
                revealList = [];
                currentPickerIndex = 0;

                // distribution de nouvelles cartes
                distribuerCartes();

                // mise √† jour du score et de l'affichage
                renderScores();

                // lancement de la phase ma√Ætre
                startMasterPick();
            }

            // start phases
            function startMasterPick() {
                phase = "master_pick";
                selections = {};
                votes = {};
                revealList = [];
                currentPickerIndex = 0;

                masterPlayer = listJoueurs[masterIndex];
                infoDiv.textContent = `üé© Le conteur est du jeu est ${masterPlayer}. √âcris une phrase et choisis une carte.`;
                phraseDiv.textContent = "";

                btnValider.classList.remove("hidden");
                btnValider.dataset.selectedIndex = "";
                inputPhrase.classList.remove("hidden");

                currentPlayerIndex = listJoueurs.indexOf(masterPlayer);
                renderHandForPlayer(masterPlayer, "pick");
            }
            // event: valider click (used both for master and for other players)
            btnValider.addEventListener("click", () => {
                if (phase === "master_pick") {
                    const idx = btnValider.dataset.selectedIndex;
                    const phrase = inputPhrase.value.trim();
                    if (idx === "" || idx === undefined) { alert("Veuillez choisir une carte !"); return; }
                    if (!phrase) { alert("Veuillez √©crire une phrase !"); return; }

                    // take card from master's hand
                    const cardSrc = mains[masterPlayer].splice(Number(idx), 1)[0];
                    selections[masterPlayer] = { carte: cardSrc, isMaster: true, phrase };
                    // prepare players pick phase
                    phase = "players_pick";
                    // set currentPickerIndex to first player after master
                    currentPickerIndex = 0;
                    // find order of players to pick (listJoueurs order excluding master)
                    pickOrder = listJoueurs.filter(p => p !== masterPlayer);
                    infoDiv.textContent = `üëâ Maintenant chaque joueur (sauf le ma√Ætre) choisit une carte, √† tour de r√¥le.`;
                    // start first picker
                    renderHandForPlayer(pickOrder[currentPickerIndex], "pick");
                    btnValider.dataset.selectedIndex = "";
                } else if (phase === "players_pick") {
                    // determine current picking player (we saved pickOrder above)
                    if (!window.pickOrder || !window.pickOrder[currentPickerIndex]) {
                        console.error("pickOrder missing");
                        return;
                    }
                    const player = window.pickOrder[currentPickerIndex];
                    const idx = btnValider.dataset.selectedIndex;
                    if (idx === "" || idx === undefined) { alert("Veuillez choisir une carte !"); return; }
                    // remove chosen card from player's hand
                    const cardSrc = mains[player].splice(Number(idx), 1)[0];
                    selections[player] = { carte: cardSrc, isMaster: false };
                    btnValider.dataset.selectedIndex = "";
                    // next player
                    currentPickerIndex++;
                    if (currentPickerIndex < window.pickOrder.length) {
                        renderHandForPlayer(window.pickOrder[currentPickerIndex], "pick");
                    } else {
                        // all players have picked
                        btnValider.classList.add("hidden");
                        inputPhrase.classList.add("hidden");
                        infoDiv.textContent = "Tous les joueurs ont choisi leur carte ! Pr√©paration du reveal.";
                        prepareRevealAndVoting();
                    }
                } else {
                    // other phases should not use this button
                }
            });

            // initial setup
            distribuerCartes();
            renderScores();
            startMasterPick();
        });
    </script>

</body>

</html>